<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Searchspace (knights_tour.Searchspace)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">Index</a> &#x00BB; <a href="../index.html">knights_tour</a> &#x00BB; Searchspace</nav><header class="odoc-preamble"><h1>Module <code><span>Searchspace</span></code></h1></header><div class="odoc-content"><div class="odoc-spec"><div class="spec module anchored" id="module-StaQue"><a href="#module-StaQue" class="anchor"></a><code><span><span class="keyword">module</span> <a href="StaQue/index.html">StaQue</a></span><span> : <a href="../Collections/Dlist_itf/module-type-S/index.html">Collections.Dlist_itf.S</a></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a t</span></span></code></div><div class="spec-doc"><p>A searchspace with solutions of a given type. For examle a type <code>int Searchspace.t</code> is a searchspace who's solutions are integers. It can be thought of as a lazy-computed collection of integers. The members of the collection can be discovered/produced incrementally by a search process.</p><p>The solutions to a searchspace may be an infinite collection. For example you could define a searchspace who's solutions are all prime numbers.</p><p>It is unspecified whether the solutions of a searchspace are cached or produced again upon every attempt to find them. The current implementation does not cache results ever. It is generally unsafe to do so in the presence of side-effects. Future implementations might try to cache results in some situations when it is deemed safe to do so.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-return"><a href="#val-return" class="anchor"></a><code><span><span class="keyword">val</span> return : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>A searchspace that contains a single solution.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-bind"><a href="#val-bind" class="anchor"></a><code><span><span class="keyword">val</span> bind : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Monadic bind. This constructs a new searchspace by feeding the results of an existing searchspace as input to a subsequent searchprocess.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(|=&gt;)"><a href="#val-(|=&gt;)" class="anchor"></a><code><span><span class="keyword">val</span> (|=&gt;) : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Operator syntax for <code>bind</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-map"><a href="#val-map" class="anchor"></a><code><span><span class="keyword">val</span> map : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Apply a function to every solution of search space.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(|-&gt;)"><a href="#val-(|-&gt;)" class="anchor"></a><code><span><span class="keyword">val</span> (|-&gt;) : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Operator syntax for <code>map</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-filter"><a href="#val-filter" class="anchor"></a><code><span><span class="keyword">val</span> filter : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Only retains solutions that match a given condition.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(|?&gt;)"><a href="#val-(|?&gt;)" class="anchor"></a><code><span><span class="keyword">val</span> (|?&gt;) : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Operator syntax for <code>filter</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-alt"><a href="#val-alt" class="anchor"></a><code><span><span class="keyword">val</span> alt : <span><span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Represents a decision between multiple alternatives.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-alt2"><a href="#val-alt2" class="anchor"></a><code><span><span class="keyword">val</span> alt2 : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Represents a decision between two alternatives.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(++)"><a href="#val-(++)" class="anchor"></a><code><span><span class="keyword">val</span> (++) : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Represents a decision between two alternatives.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span><span class="keyword">val</span> empty : <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>A searchspace with no solutions.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-defer"><a href="#val-defer" class="anchor"></a><code><span><span class="keyword">val</span> defer : <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Represents a search space constructed 'on demand' by calling function. This is useful to create compact/finite representations of infinite or very large searchspaces (only the parts of a searchspace that are actually traversed will be constructed)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-range"><a href="#val-range" class="anchor"></a><code><span><span class="keyword">val</span> range : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>A searchspace containing a 'range' of values generated using a kind of 'while loop'. <code>range start cond step</code> produces values starting at <code>start</code> and apply the <code>step</code> function to the previous value to produce a next value. It does so as long as the <code>cond</code> is true. If the <code>cond</code> is <code>false</code> initially, then this produces an empty range.</p><p>For example to create a range of numbers 1 to 10 we do:</p><pre class="language-ocaml"><code>range 1 ((&gt;=) 10) ((+) 1)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-int_range"><a href="#val-int_range" class="anchor"></a><code><span><span class="keyword">val</span> int_range : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Searchspace containing a range of integers ranging from lowerbound (1st parameter), to upperbound (2nd parameter). The bounds are inclusive. Example:</p><pre class="language-ocaml"><code>int_range 1 10</code></pre><p>Produces numbers from 1 to 10 including 10.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-search_fun"><a href="#type-search_fun" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a search_fun</span></span><span> = <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span><span class="type-var">'a</span> <a href="#type-t">t</a></span>)</span> option</span></span></code></div><div class="spec-doc"><p>This module provides different search functions that may explore the choices in a searchspace in a different order. Other functions that such as <code>to_seq</code> may take a <code>search_fun</code> as a parameter (which will determine the order in which results are produced)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-search"><a href="#val-search" class="anchor"></a><code><span><span class="keyword">val</span> search : <span><span class="type-var">'a</span> <a href="#type-search_fun">search_fun</a></span></span></code></div><div class="spec-doc"><p>Search for the next solution in a depth-first fashion until a solution is found or the searchspace is exhausted. If a solution is found, returns it alongside a reduced searchspace that can be used to search for more solutions. Otherwise it returns <code>None</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-breadth_search"><a href="#val-breadth_search" class="anchor"></a><code><span><span class="keyword">val</span> breadth_search : 
  <span><span class="optlabel">?limit</span>:<span>(<span>unit <span class="arrow">&#45;&gt;</span></span> float)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?stack_mon</span>:<span>(<span>string <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <a href="StaQue/index.html#type-t">StaQue.t</a></span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <a href="#type-search_fun">search_fun</a></span></span></code></div><div class="spec-doc"><p>Search in a mixed breadth-first and depth first fashion. This search pattern strives to strike a compromise between doing a depth-first and a breadth-first search.</p><p>Depth-first searches have the drawback for a very large searchspace that they will tend to get stuck exploring very narrow 'subtree' of the entire space. This is determined by choices made early on in the search process. These choices lead such large search spaces that the search engine will never be able to backtrack out of them to explore other parts of the space.</p><p>A breadth-first search on the other hand will explore branches in parallel (it keeps 'active branches in a queue and works on exploring each branch in turn a little bit, before moving on to exploring another branch.</p><p>This has the advantage of exploring the search space more broadly instead of getting stuck in a narrow subspace determined by early choices. However for very large spaces this will lead to an explosive growth in memory requirement (the queue grows larger and larger in an exponential fashion as the search space branches out in an exponential number of nodes in terms of the depth).</p><p>The <code>breadth_search</code> function strikes a compromise between these two extremes by using a <code>Treequence</code> data structure to keep track of active branches. The <code>Treequence</code> can be used as either a stack or a queue because it allows pushing and poping of elements on either front or back. A compromise between branching out and exploring in depths is achieved by dynamically switching between using the <code>Treequence</code> either as a stack or a queue. As the <code>Treequence</code> grows in size the ratio of operations using it as a stack vs a queue is gradually increased. Thus as the number of actively explored branches increases the tendency to explore in depth also increases; and the tendency to branch out decreases.</p><p>Optional Parameters:</p><ul><li><code>limit</code>: determines how aggressively the search space is breadth exploration will be limited as the work queue grows in size. If set to 0 then there is no limit and the work queue is always used as a queue. If set to <code>n</code>, then the number of <code>queue_ops / stack_ops</code> tends towards <code>n / active_branches</code>. The default <code>limit</code> value is <code>1</code>.</li></ul><ul><li><code>stack_mon</code>: a function that is called on every step of the search allowing a caller to monitor progress and/or collect statistical data. The default is a function that does nothing.</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-limit_on_low_memory"><a href="#val-limit_on_low_memory" class="anchor"></a><code><span><span class="keyword">val</span> limit_on_low_memory : <span><span class="label">max_memory_ratio</span>:float <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p><code>limit_on_low_memory max_ratio</code> produces a procedure suitable you can pass as a <code>limit</code> argument to <code>breadth_search</code>.</p><p>When called it computes the current ration of <code>memory_used/memory_available</code> in the host OS (note: only Linux is supported). As this ratio approaches the <code>max_memory_ratio</code>, the limit becomes ever more aggressive at limiting 'breadth exploration' to curb additional memory consumption.</p><p>As the max_memory usage is reached or exceeded the search becomes a pure 'depth_first' search until more memory is again available.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_seq"><a href="#val-to_seq" class="anchor"></a><code><span><span class="keyword">val</span> to_seq : <span><span class="optlabel">?search</span>:<span><span class="type-var">'a</span> <a href="#type-search_fun">search_fun</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span></span></code></div><div class="spec-doc"><p>Converts a searchspace into a <code>Seq</code> of its solutions. The solutions are produced incrementally as required. So it is fine to convert a searchspace of infinite solutions to a <code>Seq</code>. An optional <code>search_fun</code> may be provided to alter the order in which solutions are being generated.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_seq"><a href="#val-of_seq" class="anchor"></a><code><span><span class="keyword">val</span> of_seq : <span><span><span class="type-var">'a</span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Represents a decision between multiple potentially infinite alternatives as given by the elements of a <code>Seq</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_list"><a href="#val-of_list" class="anchor"></a><code><span><span class="keyword">val</span> of_list : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Represents a decision between mupliple values as given by a list</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-nats"><a href="#val-nats" class="anchor"></a><code><span><span class="keyword">val</span> nats : <span>int <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>searchspace containing all natural numbers. WARNING: must handle with care because it is an infinite searchspace.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-nat_pairs"><a href="#val-nat_pairs" class="anchor"></a><code><span><span class="keyword">val</span> nat_pairs : <span><span>(int * int)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>searchspace of all pairs of natural numbers</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-no_dup"><a href="#val-no_dup" class="anchor"></a><code><span><span class="keyword">val</span> no_dup : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>filters out duplicate solutions. Note that this operation is quite expensive because it creates a Set data structure to keep track of all previously encountered elements in order to detect any duplicates.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_decision_tree"><a href="#val-pp_decision_tree" class="anchor"></a><code><span><span class="keyword">val</span> pp_decision_tree : 
  <span><span>(<span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>print out a pretty decision tree, using indentation to show structure</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-node_view"><a href="#type-node_view" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a node_view</span></span><span> = </span></code><ol><li id="type-node_view.Result" class="def variant constructor anchored"><a href="#type-node_view.Result" class="anchor"></a><code><span>| </span><span><span class="constructor">Result</span> <span class="keyword">of</span> <span class="type-var">'a</span></span></code></li><li id="type-node_view.Fork" class="def variant constructor anchored"><a href="#type-node_view.Fork" class="anchor"></a><code><span>| </span><span><span class="constructor">Fork</span> <span class="keyword">of</span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> list</span></span></code></li><li id="type-node_view.Fail" class="def variant constructor anchored"><a href="#type-node_view.Fail" class="anchor"></a><code><span>| </span><span><span class="constructor">Fail</span></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-inspect"><a href="#val-inspect" class="anchor"></a><code><span><span class="keyword">val</span> inspect : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-node_view">node_view</a></span></span></code></div></div></div></body></html>
