# OCaml Pentomino Solver Long-Running Process UI Design

## Project Context
- GitHub: https://github.com/kdvolder/knights_tour
- **2+ years continuous runtime** on oracle2 (since 2023, ~1M CPU minutes)
- Current memory usage: 15.2GB anonymous pages (~52-60% of 24GB total RAM)
- Process: `solve_file` running at 99.9% CPU utilization
- Cannot stop process without losing accumulated state

## Current File-Based Interface
**Location:** `/home/ubuntu/git/knights_tour/saves/2023.09.30-13.40.25/`

### Files Generated:
1. **snapshot-treequence.txt** - Current puzzle state in ASCII art format
   - Letters represent different pieces, dots = empty, # = holes
   - Only updates on "high points": deeper search depth or actual solutions
   - Efficient design - rare but meaningful updates

2. **stats-treequence.csv** - 2M+ data points of search statistics
   - **146MB file** with continuous metrics every ~10 seconds
   - 8 columns of search algorithm data

### CSV Column Definitions:
1. **Total steps tried** (piece placements attempted)
2. **Steps since last dequeue** (current depth-first run length)  
3. **Total dequeues** (breadth-first resets since start)
4. **Queue size** (current search queue size - proxy for RAM usage)
5. **Average branching factor** (queue size / dequeues)
6. **Solutions found** (complete puzzle solutions discovered)
7. **Steps per solution** (search efficiency metric)
8. **Steps per second** (processing performance)

## Algorithm Design Insights
- **Adaptive search strategy**: Dynamically balances depth-first vs breadth-first
- **Memory-aware**: Formula designed to asymptotically approach 0% dequeue rate before RAM exhaustion
- **Self-regulating**: Uses queue size as RAM usage proxy (queue ≈ 15.2GB at current state)
- **Survival-focused**: Gracefully transitions to pure depth-first to avoid memory crashes

## Proposed UI Architecture

### Backend (Non-Intrusive)
- **TypeScript/Node.js** preferred (statically typed, good tooling)
- **File watching** approach - monitor existing files without process modification
- **WebSocket/SSE** for real-time updates to browser
- **CSV streaming** to handle 146MB stats file efficiently

### Frontend Visualizations
1. **Current State Display**
   - ASCII board rendered as visual puzzle with colored pieces
   - Real-time updates when snapshot file changes

2. **Algorithm Evolution Timeline** (2+ year data)
   - Search strategy transition: exploration → exploitation
   - Memory pressure trends (queue size growth)
   - Dequeue percentage decay over time

3. **Performance Analytics**
   - Solutions discovery timeline
   - Search efficiency trends (steps per solution)
   - Processing speed over 2+ years
   - Memory usage stabilization around 60% system RAM

4. **Search Behavior Analysis**
   - Depth-first vs breadth-first balance over time
   - "Breakthrough moments" when major progress occurred
   - Algorithm learning curve and adaptation patterns

### Technical Implementation
```typescript
interface SolverState {
  board: string[];           // ASCII board lines
  timestamp: number;         // Latest progress
  queueSize: number;         // Memory proxy
  solutionsFound: number;    // Total solutions
  searchDepth: number;       // Current depth indicator
}

interface Milestone {
  timestamp: Date;
  board: string[];
  depth: number;
  isSolution: boolean;
  searchStats: SolverStats;
}
```

## Memory Analysis Context
- **System**: 24.5GB total RAM, no swap
- **Current usage**: 15.2GB anonymous (solver), 7.3GB cache, 975MB free
- **Algorithm success**: Stable at ~60% RAM usage for sustained operation
- **Queue size ~418K** correlates to ~15.2GB actual memory usage

## Future Implementation Notes
- Use Chart.js or D3.js for rich interactive graphs
- Time-bucketed aggregations (daily/weekly/monthly views)
- Solution gallery showing all discovered solutions
- "Learning curve" visualization of algorithm's 2-year evolution
- Performance regression detection over time